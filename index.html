# What I built for you now

Below are **ready-to-drop patches** to: (1) polish the admin dashboard, (2) enable one-click **Download Word** from the admin list, and (3) upgrade the AI prompt to your outcome-based model. These keep your existing flows intact.

---

## 1) Admin dashboard polish (+ download buttons)

**Goals:** quick triage; search, filter, status badges; and per-row **Download .docx** button that hits `/api/export?id=...`.

### `/public/admin.html` (replace the whole file)

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Admin — Strategy Draft Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet" />
    <style>
      :root { --bg:#0b1020; --panel:#121830; --muted:#8a93a6; --text:#e6eaf3; --ok:#16a34a; --warn:#eab308; --bad:#ef4444; --chip:#1f2a4d; }
      *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,sans-serif;background:var(--bg);color:var(--text)}
      header{display:flex;gap:12px;align-items:center;padding:16px 20px;border-bottom:1px solid #1c2445;position:sticky;top:0;background:rgba(11,16,32,.75);backdrop-filter:saturate(120%) blur(8px)}
      h1{font-size:16px;margin:0;font-weight:600;color:#b8c2e0}
      .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
      input,select,button{background:#0f1530;border:1px solid #202a52;color:var(--text);padding:8px 10px;border-radius:10px}
      input::placeholder{color:#7380a6}
      button{cursor:pointer}
      main{max-width:1100px;margin:18px auto;padding:0 18px}
      table{width:100%;border-collapse:separate;border-spacing:0 10px}
      th{font-size:12px;color:#94a3c7;text-align:left;font-weight:600;padding:0 10px}
      td{background:var(--panel);border:1px solid #1c2445;border-radius:12px;padding:12px 10px}
      tr td:first-child{border-top-right-radius:0;border-bottom-right-radius:0}
      tr td:last-child{border-top-left-radius:0;border-bottom-left-radius:0}
      .chips{display:flex;gap:6px;flex-wrap:wrap}
      .chip{background:var(--chip);color:#cbd5f6;border:1px solid #2b3764;padding:4px 8px;border-radius:999px;font-size:12px}
      .status{font-size:12px;font-weight:600;padding:4px 10px;border-radius:999px;display:inline-block}
      .s-new{background:#17325a;color:#9cc2ff;border:1px solid #244a89}
      .s-in{background:#2b1f57;color:#d2b8ff;border:1px solid #443187}
      .s-done{background:#0f3e2a;color:#7ce2aa;border:1px solid #195f40}
      .actions{display:flex;gap:8px;flex-wrap:wrap}
      .ghost{background:transparent;border-color:#2a3564}
      .danger{border-color:#5b2630;color:#ffb4c0}
      .mono{font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; color:#9fb0d8}
      .pager{display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:12px}
      a.file{color:#a6c0ff;text-decoration:none}
    </style>
  </head>
  <body>
    <header>
      <h1>Admin</h1>
      <div class="row" style="margin-left:auto">
        <input id="token" type="password" placeholder="ADMIN_TOKEN" />
        <input id="q" placeholder="Search (org, contact, notes)" />
        <select id="status">
          <option value="">All statuses</option>
          <option value="new">New</option>
          <option value="in_progress">In progress</option>
          <option value="done">Done</option>
        </select>
        <button id="load">Load</button>
      </div>
    </header>
    <main>
      <table id="tbl">
        <thead>
          <tr>
            <th style="width:22%">Org / Contact</th>
            <th style="width:32%">Summary</th>
            <th style="width:22%">Files</th>
            <th style="width:10%">Status</th>
            <th style="width:14%">Actions</th>
          </tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
      <div class="pager">
        <button class="ghost" id="prev">Prev</button>
        <span id="page" class="mono"></span>
        <button class="ghost" id="next">Next</button>
      </div>
    </main>

    <script>
      const state = { page: 1, pageSize: 20, total: 0, items: [] };

      function badge(s){
        if(s==='done') return '<span class="status s-done">Done</span>';
        if(s==='in_progress') return '<span class="status s-in">In progress</span>';
        return '<span class="status s-new">New</span>';
      }

      function fileLink(u){ return `<a class="file" href="${u}" target="_blank">${u.split('/').pop()}</a>` }

      async function fetchList(){
        const token = document.getElementById('token').value.trim();
        if(!token){ alert('Enter ADMIN_TOKEN'); return; }
        const q = document.getElementById('q').value.trim();
        const status = document.getElementById('status').value;
        const url = new URL(location.origin + '/api/admin/submissions');
        url.searchParams.set('page', state.page);
        url.searchParams.set('pageSize', state.pageSize);
        if(q) url.searchParams.set('q', q);
        if(status) url.searchParams.set('status', status);
        const res = await fetch(url, { headers: { 'x-admin-token': token }});
        if(!res.ok){ alert('Auth failed or API error'); return; }
        const data = await res.json();
        state.total = data.total || data.items?.length || 0;
        state.items = data.items || [];
        render();
      }

      function render(){
        const rows = document.getElementById('rows');
        rows.innerHTML = state.items.map(item=>{
          const files = (item.files||[]).map(fileLink).join('<br/>');
          const id = item.id || item.key || item._id;
          return `<tr>
            <td>
              <div style="font-weight:600">${item.organization||'—'}</div>
              <div class="mono">${item.contact_name||'—'} · ${item.contact_email||'—'}</div>
              <div class="mono">${new Date(item.created_at||item.createdAt).toLocaleString()}</div>
            </td>
            <td>${(item.summary||item.notes||'—').slice(0,180)}</td>
            <td>${files||'—'}</td>
            <td>${badge(item.status||'new')}</td>
            <td class="actions">
              <button class="ghost" onclick="openOne('${id}')">Open</button>
              <button class="ghost" onclick="mark('${id}','in_progress')">Mark In Progress</button>
              <button class="ghost" onclick="mark('${id}','done')">Mark Done</button>
              <button onclick="downloadDocx('${id}')">Download .docx</button>
            </td>
          </tr>`
        }).join('');
        document.getElementById('page').textContent = `Page ${state.page}`;
      }

      async function openOne(id){
        const token = document.getElementById('token').value.trim();
        const res = await fetch(`/api/admin/submission?id=${encodeURIComponent(id)}`, { headers: { 'x-admin-token': token }});
        if(!res.ok){ alert('Open failed'); return; }
        const data = await res.json();
        const pretty = JSON.stringify(data, null, 2);
        const w = window.open('', '_blank');
        w.document.write('<pre style="white-space:pre-wrap">'+pretty+'</pre>');
      }

      async function mark(id,status){
        const token = document.getElementById('token').value.trim();
        const res = await fetch('/api/admin/mark', { method:'POST', headers: { 'content-type':'application/json', 'x-admin-token': token }, body: JSON.stringify({ id, status })});
        if(res.ok){ fetchList(); } else { alert('Mark failed'); }
      }

      function downloadDocx(id){
        const url = `/api/export?id=${encodeURIComponent(id)}`;
        const a = document.createElement('a');
        a.href = url; a.download = '';
        document.body.appendChild(a); a.click(); a.remove();
      }

      document.getElementById('load').onclick = ()=>{ state.page=1; fetchList(); };
      document.getElementById('prev').onclick = ()=>{ if(state.page>1){ state.page--; fetchList(); } };
      document.getElementById('next').onclick = ()=>{ state.page++; fetchList(); };
    </script>
  </body>
</html>
```

> Assumes your `/api/admin/submissions` already accepts `page`, `pageSize`, `q`, and `status`. If not, see the small patch in section **1.1** below.

### 1.1 `/api/admin/submissions.js` (optional: add query, filter, paging)

```js
export default async function handler(req, res){
  if(req.headers['x-admin-token'] !== process.env.ADMIN_TOKEN){
    return res.status(401).json({ error: 'unauthorized' });
  }
  const page = parseInt(req.query.page||'1',10);
  const pageSize = Math.min(parseInt(req.query.pageSize||'20',10), 100);
  const q = (req.query.q||'').toLowerCase();
  const status = req.query.status||'';

  // TODO: replace with your real Blob listing
  const { listSubmissions } = await import('../../lib/blob.js');
  const all = await listSubmissions();

  const filtered = all.filter(x=>{
    const hitQ = !q || JSON.stringify(x).toLowerCase().includes(q);
    const hitS = !status || (x.status===status);
    return hitQ && hitS;
  });
  const start = (page-1)*pageSize;
  const items = filtered.slice(start, start+pageSize);
  res.json({ total: filtered.length, items });
}
```

---

## 2) One‑click Word export from Admin

**Goal:** let admins download the exact .docx export for any submission **by id**. This extends your existing `/api/export.js` to support `GET ?id=...` while preserving current `POST` behavior.

### `/api/export.js` (augment)

```js
import { getSubmissionById } from '../lib/blob.js';
import { generateDocxBuffer } from '../lib/export/docx.js';

export const config = { api: { bodyParser: { sizeLimit: '1mb' }}};

export default async function handler(req, res){
  try{
    let data;
    if(req.method === 'GET' && req.query.id){
      // Admin GET by id
      if(req.headers['x-admin-token'] !== process.env.ADMIN_TOKEN){
        return res.status(401).json({ error: 'unauthorized' });
      }
      data = await getSubmissionById(req.query.id);
    } else if(req.method === 'POST'){
      // Existing flow: client posts assembled payload
      data = req.body;
    } else {
      return res.status(400).json({ error: 'Unsupported' });
    }

    const buf = await generateDocxBuffer(data);
    const filename = (data.organization?.replace(/[^a-z0-9-_]+/gi,'_') || 'strategy_draft') + '.docx';
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.status(200).send(Buffer.from(buf));
  } catch(e){
    console.error(e);
    res.status(500).json({ error: 'export_failed' });
  }
}
```

### `/lib/blob.js` (new helper)

```js
import { list, get } from '@vercel/blob';

export async function listSubmissions(){
  const { blobs } = await list({ prefix: 'submissions/' });
  const out = [];
  for(const b of blobs){
    if(!b.pathname.endsWith('.json')) continue;
    const r = await fetch(b.url, { headers: { 'Authorization': `Bearer ${process.env.BLOB_READ_WRITE_TOKEN}` }});
    const j = await r.json();
    out.push(j);
  }
  // Sort newest first
  out.sort((a,b)=> new Date(b.created_at||b.createdAt) - new Date(a.created_at||a.createdAt));
  return out;
}

export async function getSubmissionById(id){
  // Files are saved as submissions/{id}.json per your submit.js
  const key = `submissions/${id}.json`;
  const { blobs } = await list({ prefix: 'submissions/' });
  const hit = blobs.find(b=> b.pathname === key);
  if(!hit) throw new Error('not_found');
  const r = await fetch(hit.url, { headers: { 'Authorization': `Bearer ${process.env.BLOB_READ_WRITE_TOKEN}` }});
  return await r.json();
}
```

### `/lib/export/docx.js` (new; uses docx)

```js
import { Document, Packer, Paragraph, HeadingLevel, TextRun } from 'docx';

export async function generateDocxBuffer(data){
  const doc = new Document({ sections: [{ properties: {}, children: build(data) }] });
  return await Packer.toBuffer(doc);
}

function build(d){
  const out = [];
  const H = (text)=> new Paragraph({ text, heading: HeadingLevel.HEADING_1 });
  const H2 = (text)=> new Paragraph({ text, heading: HeadingLevel.HEADING_2 });
  const P = (text)=> new Paragraph({ children: [ new TextRun(text||'') ] });

  out.push(H(d.organization||'Strategy Draft'));
  if(d.contact_name||d.contact_email){
    out.push(P(`Contact: ${d.contact_name||''} ${d.contact_email?'· '+d.contact_email:''}`));
  }
  if(d.summary) out.push(P(d.summary));

  if(Array.isArray(d.outcomes) && d.outcomes.length){
    out.push(H('Outcomes'));
    d.outcomes.forEach((o,i)=>{
      out.push(H2(`${i+1}. ${o.title||o.name||'Outcome'}`));
      if(o.description) out.push(P(o.description));
      if(Array.isArray(o.behaviors)){
        o.behaviors.forEach(b=> out.push(P('• '+b)));
      }
    });
  }

  if(Array.isArray(d.modules) && d.modules.length){
    out.push(H('Modules'));
    d.modules.forEach((m,i)=>{
      out.push(H2(`${i+1}. ${m.title||m.name||'Module'}`));
      if(m.objective) out.push(P('Objective: '+m.objective));
      if(Array.isArray(m.activities)){
        m.activities.forEach(a=> out.push(P('– '+a)));
      }
    });
  }

  return out;
}
```

> If you already have a Word generation routine, you can point `generateDocxBuffer` to it and keep the public API the same.

---

## 3) Improve AI prompt (outcome‑based; business‑impact)

**Goal:** tighten outputs to your model: observable behaviors, sequencing into modules, and contextual practice with constraints.

### `/api/draft.js` (swap in this prompt skeleton)

```js
import OpenAI from 'openai';
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const SYSTEM_PROMPT = `You are an AI Instructional Designer at Legacy Learning Consulting. Your job is to produce a *strategy draft* that is:
- **Outcome-based**: define 3–6 learner outcomes as *observable behaviors* aligned to the client's business goals.
- **Behavior practice forward**: recommend activities that embed practice in day-to-day work.
- **Feasible**: consider constraints (audience size, time, delivery, tools) and sequence into 3–8 modules.
- **Measurable**: include success signals and simple ways to capture behavior change.

Return JSON with: { organization, summary, outcomes:[{title, description, behaviors[]}], modules:[{title, objective, activities[]}], notes }.
Keep language concise, plain, and client-ready.`;

export default async function handler(req,res){
  try{
    const input = req.body; // { organization, goals, audience, constraints, ... }
    const userPrompt = `Client info: ${JSON.stringify(input)}\n\nPlease produce the JSON described in SYSTEM_PROMPT.`;

    const completion = await client.chat.completions.create({
      model: 'gpt-4.1-mini',
      temperature: 0.3,
      messages: [
        { role:'system', content: SYSTEM_PROMPT },
        { role:'user', content: userPrompt }
      ],
      response_format: { type:'json_object' }
    });

    const json = JSON.parse(completion.choices[0].message.content);
    res.json(json);
  }catch(e){
    console.error(e);
    res.status(500).json({ error:'draft_failed' });
  }
}
```

> Swap models as you wish; structure nudges the model toward clean, consistent JSON and business-impact framing.

---

## 4) (Optional) Quick client‑side PDF button (no server changes)

If you want a simple PDF from the **browser** (works on most submissions/details screens), add a button that prints the JSON to a styled HTML and calls `window.print()` or `html2pdf` CDN. This avoids headless chrome in serverless. Ping me if you want the full snippet wired into your current UI.

---

## How to deploy

1. Add the new files:

   * `lib/blob.js`
   * `lib/export/docx.js`
2. Replace `public/admin.html` with the version above (or merge the `<script>` and styles).
3. Update `api/export.js` as shown.
4. `vercel deploy` (or push to your GitHub if auto-deploy).

No new env vars are required (uses existing `ADMIN_TOKEN` and `BLOB_READ_WRITE_TOKEN`).

---

## Next ideas (pick any for the next pass)

* **Admin: CSV export** of the table with applied filters.
* **Tagging** submissions (priority, client segment) and filter by tag.
* **Email webhook**: On mark `done`, email the requester a link to the .docx in Blob.
* **PDF export (server)** using `puppeteer-core` + `@sparticuz/chromium`, pre-rendering a nice HTML report.
* **Rate limits / retries** on `draft.js` (429/backoff) and streaming partial results UI.
